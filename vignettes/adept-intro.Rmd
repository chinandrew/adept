---
title: "Introduction to adept package"
author: "Marta Karas"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: yes
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Introduction to adept package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = FALSE
)
```



# Intro

`adept` package implements ADaptive Empirical Pattern Transformation (ADEPT) **for pattern segmentation in a time-series `x`**. ADEPT was designed for identification of walking strides in sub-second level data collected with wearable accelerometers. The ADEPT has been tested ([1]) for data collected with sensors worn at left wrist, left hip and both ankles.  

This vignette introduces ADEPT algorithm and demonstrates the usage of `segmentPattern` function which implements ADEPT approach. Here, we focus on examples with simulated data; see the [Walking strides segmentation with adept](file://localhost/Users/martakaras/Dropbox/_PROJECTS/R/adept/docs/articles/adept-strides-segmentation.html) vignette for an example of walking stride segmentation in real-life  data.

# ADEPT method   

ADEPT identifies patterns in a time-series `x` via maximization of chosen similarity statistic (correlation, covariance etc.) between a time-series `x` and a pattern template(s). It accounts for a variability in both (1) pattern duration and (2) pattern shape.

## Pattern template

We define pattern template as a 1-dimensional numeric vector which values represent the pattern of interest (e.g. accelerometry data of a human stride). In practice, a pattern template may be derived based on some pre-segmented small part of the data. 

- See [1] where we show a way to derive walking stride templates from accelerometry data collected at left wrist, left hip and both ankles.
- See [2] where we employed templates derived in [1] to segment stride pattern from a another accelerometry data set. 

In this vignette, a pattern template is a simulated data vector. 

# Install and load `adept` package

If not installed yet, install `adept` package from GitHub (`devtools` package is needed to install a package from a GitHub repository).

```{r, eval = FALSE}
# install.packages("devtools")      
devtools::install_github("martakarass/adept")
```

Load `adept`.

```{r}
library(adept)
library(magrittr)
library(ggplot2)
```

# Pattern segmentation with `adept` package  

The examples below are organized into suites. Examples within one suite share data generation settings, for example: *Examples 1: signals simulated with no noise, same-length pattern*. 

## Examples 1: signal with no noise, same length of pattern occurrences

### Simulate data

Simulate data: 

- no noise in a simulated time-series `x`,
- all pattern occurrences of the same length (vector length: `101`).

```{r, fig.width=7, fig.height=2.3}
## Generate signal and pattern template
x0 <- cos(seq(0, 2 * pi * 10, length.out = 1001))
x  <- x0
template <- x0[1:101]

## Plot time-series `x`
data.frame(x = 1:length(x), y = x) %>%
  ggplot() + geom_line(aes(x = x, y = y)) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x")
```

Plot pattern template. We shall use `template` object in the segmentation algorithm. 

```{r, fig.width=2.5, fig.height=2.3}
data.frame(x = seq(0, 1, length.out = 101), y = template) %>%
  ggplot() + 
  geom_line(aes(x = x, y = y), color = "red") + 
  theme_bw(base_size = 9) + 
  labs(x = "Template phase", y = "Value", title = "Pattern template")
```

### Example 1(a): segment pattern 

Use `segmentPattern` function to identify pattern occurrences within a time-series `x`. 

```{r}
pattern.dur.seq <- c(90, 100, 110)
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
```

#### `segmentPattern` output 

Each row of the output data frame describes one identified pattern occurrence. See Details in `segmentPattern` documentation. 

- `tau_i` - pattern occurrence start, expressed as a time-series `x` index,
- `T_i` - pattern occurrence duration, expressed as a time-series `x` vector length,
- `sim_i` - similarity (here: correlation) between a pattern template and a time-series `x` window, 
- `template_i` - index of a pattern template to which a time-series `x` window was matched (here: one pattern template was used, hence all `template_i`'s equal 1). 

### Example 1(b): use `pattern.dur.seq` to modify a grid of pattern duration 

Use dense grid of pattern duration, including value `101` used in signal simulation. Observe that perfect match (`sim_i = 1`) between template time-series `x` windows is obtained. 

```{r}
pattern.dur.seq <- 90:110  ## Assume dense pattern duration grid ranging 90-110 seconds
out <- segmentPattern(
  x = x,
  x.fs = 1,  
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
```

### Example 1(c): use `x.fs` to modify `x` time-series frequency

Use `x.fs` to modify `x` time-series frequency, expressed in a number of observations in seconds. Adjust `pattern.dur.seq` accordingly. Observe that results stay the same as in  Example 1(b). 

```{r}
pattern.dur.seq <- 90:110 * 0.01   ## Assume pattern duration grid ranging 0.9-1.1 seconds
out <- segmentPattern(
  x = x,
  x.fs = 100,   ## Assume data frequency 100 observations per second
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
```



## Examples 2: signal with no noise, length of pattern occurrences varies

### Simulate data

Simulate data: 

- no noise in a simulated time-series `x`,
- length of simulated pattern occurrences vary. 

```{r, fig.width=7, fig.height=2.3}
set.seed(1)
## Simulate x as concatenated pattern occurrences of different length 
true.pattern <- cos(seq(0, 2 * pi, length.out = 200))
s.grid <- sample(60:120, size = 10)
x <- numeric()
for (s.tmp in s.grid){
  true.pattern.s <- approx(
    seq(0, 1, length.out = 200), 
    true.pattern, 
    xout = seq(0, 1, length.out = s.tmp))$y
  if (length(x) > 0){
    x <- c(x, true.pattern.s[-1])
  } else {
    x <- c(x, true.pattern.s)
  }
}

## Define template used further in segmentation 
template <- true.pattern
```

Plot time-series `x`. 

```{r, fig.width=7, fig.height=2.3}
data.frame(x = 1:length(x), y = x) %>%
  ggplot() + geom_line(aes(x = x, y = y)) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x")
```

Plot template. 

```{r, fig.width=2.5, fig.height=2.3}
data.frame(x = seq(0, 1, length.out = length(template)), y = template) %>%
  ggplot() + geom_line(aes(x = x, y = y), color = "red") + 
  theme_bw(base_size = 9) + labs(x = "Template phase", y = "Value", title = "Template")
```

```{r}
## Function to plot segmentation results with ggplot2
library(ggplot2)
out.plot1 <- function(val, out){
  yrange <- c(-1, 1) * max(abs(val))
  y.h <- 0
  plt <- ggplot()
  for (i in 1:nrow(out)){
    tau1_i <- out[i, "tau_i"]
    tau2_i <- tau1_i + out[i, "T_i"] - 1
    plt <- 
      plt + 
      geom_vline(xintercept = tau1_i, color = "red") + 
      geom_vline(xintercept = tau2_i, color = "red") + 
      annotate(
        "rect",
        fill = "pink", 
        alpha = 0.3,
        xmin = tau1_i, 
        xmax = tau2_i, 
        ymin = yrange[1],
        ymax = yrange[2]
    )
  }
  plt <- 
    plt + 
    geom_line(data = data.frame(x = 1:length(val), y = val), 
              aes(x = x, y = y), 
              color = "black", 
              size = 0.3) + 
    theme_bw(base_size = 9) + 
    labs(x = "Time [s]", y = "Black line: x",
         title = "Black line: signal x\nRed vertical lines: start and end points of identified pattern occurrence\nRed shaded area: area corresponding to identified pattern occurrence")
  plot(plt)
}

```

### Example 2(a): segment pattern

Use a dense grid of pattern duration, including all values used in signal simulation. Observe that perfect match (`sim_i = 1`) between template time-series `x` windows is obtained. In this example, the start and end points of identified pattern occurrences (marked with red vertical lines in the plot below) do overlap. 

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x, out)
```


### Example 2(b): use `pattern.dur.seq` to modify a grid of pattern duration

Use less dense grid of pattern duration and observe that perfect match (`sim_i = 1`) between template time-series `x` windows is no longer obtained. Note: 

- A less dense `pattern.dur.seq` grid yields shorter time of method execution.
- As explained later, when peak detection tuning is used, having a "maximally dense" pattern duration grid does not contribute much.

```{r }
pattern.dur.seq <- c(60, 90, 120)
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
```

```{r, fig.width=7, fig.height=2.3}
out.plot1(x, out)
```

### Example 2(c): use `similarity.measure` to modify similarity statistic

Use `similarity.measure` to modify similarity statistic. Observe that `sim_i` values in the result data frame do change and the segmentation results change slightly too (explanation: a change of similarity statistic affects ADEPT iterative maximization procedure). 

```{r }
pattern.dur.seq <- c(60, 90, 120)
  out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cov",  ## Use covariance as a similarity statistic
  compute.template.idx = TRUE)
out
```

```{r, fig.width=7, fig.height=2.3}
out.plot1(x, out)
```



## Examples 3: signal with no noise, length of pattern occurrences and pattern shape vary

### Simulate data

Simulate data: 

- no noise in simulated time-series `x`,
- length of simulated pattern occurrences varies (vector length ranges between `60` and `120`),
- two different patterns used to simulate a time-series `x`.  

```{r, fig.width=7, fig.height=2.3}
## Simulate x as concatenated pattern occurrences of 
## different length and different shape
set.seed(1)
s.grid <- sample(60:120, size = 5)
true.pattern.1 <- cos(seq(0, 2 * pi, length.out = 200))
true.pattern.2 <- true.pattern.1
seq.tmp <- 70:130
true.pattern.2[seq.tmp] <- 2 * true.pattern.2[min(seq.tmp)] + abs(true.pattern.2[seq.tmp])
x <- numeric()
for (ss in s.grid){
  true.pattern.1.s <- approx(
    seq(0, 1, length.out = 200), 
    true.pattern.1, 
    xout = seq(0, 1, length.out = ss))$y
  if (length(x) > 0){
    x <- c(x, true.pattern.1.s[-1])
  } else {
    x <- c(x, true.pattern.1.s)
  }
  true.pattern.2.s <- approx(
    seq(0, 1, length.out = 200), 
    true.pattern.2,
    xout = seq(0, 1, length.out = ss))$y
  x <- c(x, true.pattern.2.s[-1])
}
```

Plot time-series `x`.

```{r, fig.width=7, fig.height=2.3}
## Plot time-series `x`
data.frame(x = 1:length(x), y = x) %>%
  ggplot() + geom_line(aes(x = x, y = y)) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x")
```

Plot two vectors that were used in time-series `x` simulation.

```{r, fig.width=2.5, fig.height=2.3}
plt1 <- 
  data.frame(x = seq(0, 1, length.out = length(true.pattern.1)), y = true.pattern.1) %>%
  ggplot() + geom_line(aes(x = x, y = y), color = "red") + 
  theme_bw(base_size = 9) + labs(x = "Template phase", y = "Value", title = "Template 1") + 
  scale_y_continuous(limits = c(-1,1))
plt2 <- 
  data.frame(x = seq(0, 1, length.out = length(true.pattern.2)), y = true.pattern.2) %>%
  ggplot() + geom_line(aes(x = x, y = y), color = "red") + 
  theme_bw(base_size = 9) + labs(x = "Template phase", y = "Value", title = "Template 2") + 
  scale_y_continuous(limits = c(-1,1))
plt1;plt2
```



### Example 3(a): segment pattern

Use a dense grid of pattern duration. Use `template` object consisting of only one out of two "true" patterns used in `x` simulation.   

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
template <- true.pattern.1 ## Template consisting of one out of two "true" patterns
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x, out)
```


### Example 3(b): use `similarity.measure.thresh` to modify threshold of minimal similarity 

Use similarity threshold so as all identified pattern occurrences have similarity (here: covariance) greater than the threshold value. Using threshold may substantially speed up method execution. 

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
template <- true.pattern.1
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  similarity.measure.thresh = 0.95, 
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x, out)
```


### Example 3(c): use multiple templates simultaneously

Use two templates simultaneously in segmentation. Observe that the index of a pattern template to which a time-series `x` window was matched is `1` and `2` interchangeably, as displayed in `template_i` column of the output data frame. 

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
## Use two templates simultaneously in segmentation
template <- list(true.pattern.1,
                 true.pattern.2)
out <- segmentPattern(
  x = x,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x, out)
```



## Examples 4: signal with noise, length of pattern occurrences and pattern shape vary


### Simulate data

Simulate data: 

- add noise to a simulated time-series `x`,
- length of simulated pattern occurrences varies (vector length ranges between `60` and `120`),
- two different true pattern shapes within a time-series `x`.  

Here, we use `x` generated above in Examples 3.  

```{r, fig.width=7, fig.height=2.3}
## Add noise to x generated in Examples 3
set.seed(1)
x2 <- x + rnorm(length(x), sd = 0.5)
```

Plot time-series `x`.

```{r, fig.width=7, fig.height=2.3}
data.frame(x = 1:length(x2), y = x2) %>%
  ggplot() + geom_line(aes(x = x, y = y), size = 0.3) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x")
```


### Example 4(a): segment pattern

Use two templates simultaneously in segmentation. 

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
template <- list(true.pattern.1,
                 true.pattern.2)
  
out <- segmentPattern(
  x = x2,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x2, out)
```


### Example 4(b): use `x.adept.ma.W` to smooth `x` for similarity matrix computation

Use `x.adept.ma.W` to define a length of a smoothing window to smooth `x` for similarity matrix computation; `x.adept.ma.W` is expressed in seconds and the default is `NULL` (no smoothing applied).

**Smoothing of a time-series `x`**

Function `windowSmooth` allows to observe the effect of smoothing for different values of smoothing window length `W`. `W` is expressed in seconds.  

* Here, `W = 10` seems to be a plausible choice. 

```{r, fig.width=7, fig.height=2.3}
x2.smoothed <- windowSmooth(x = x2, x.fs = 1, W = 10)

data.frame(x = 1:length(x2.smoothed), y = x2.smoothed) %>%
  ggplot() + geom_line(aes(x = x, y = y)) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x smoothed")
```

Use `x.adept.ma.W = 10` and compare with results from Example 4(a). Observe that using a smoothed version of `x` in similarity matrix computation is pronounced in `sim_i` values in the output data frame, as well as in a slight change in `tau_i` and `T_i` values.

```{r, fig.width=7, fig.height=2.3}
out <- segmentPattern(
  x = x2,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  x.adept.ma.W = 10,
  compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x2, out)
```

### Example 4(c): use fine-tune procedure for peak detection

Employ a fine-tuning procedure for stride identification. See `segmentPattern` documentation for more details. 

**Fine-tune procedure `"maxima"`** 

Fine-tune procedure `"maxima"` tunes preliminarily identified start and end of a pattern occurrence so as they correspond to local maxima of `x` found within neighbourhoods of the preliminary locations. 

* The parameter `finetune.maxima.nbh.W`, expressed in seconds, defines a length of the two neighborhoods within which we search for local maxima. 
* Smoothed version of `x` may be used for local maxima search (as presented later). 

```{r, fig.width=7, fig.height=2.3}
out <- segmentPattern(x = x2,
                      x.fs = 1,
                      template = template,
                      pattern.dur.seq = pattern.dur.seq,
                      similarity.measure = "cor",
                      x.adept.ma.W = 10,
                      finetune = "maxima",
                      finetune.maxima.nbh.W = 30,
                      compute.template.idx = TRUE)
out

## Plot segmetation results
out.plot1(x2, out)
```

Observe that almost all identified pattern occurrence start/end points are hitting the time point which our eyes identify as local `x` maxima. The exception happens around time point `600`; explanation: it originates from the restriction that identified pattern occurrence is no longer than `120` seconds given we used pattern duration grid ranging from `60` to `120` seconds. 

### Example 4(d): use fine-tune procedure and smooth signal for peak detection

Smooth `x` for both similarity matrix computation (set `x.adept.ma.W = 10`) and for  fine-tune peak detection procedure (set `finetune.maxima.nbh.W = 30`). 

* Here, `W = 50` seems like a plausible choice for fine-tune peak detection procedure as it removes ("smooth together") multiple local maxima of `x`, leaving out a single one. 

```{r, fig.width=7, fig.height=2.3}
x2.smoothed <- windowSmooth(x = x2, x.fs = 1, W = 50)

data.frame(x = 1:length(x2.smoothed), y = x2.smoothed) %>%
  ggplot() + geom_line(aes(x = x, y = y)) +  theme_bw(base_size = 9) + 
  labs(x = "Time [s]", y = "Value", title = "Time-series x smoothed aggresively")
```

```{r, fig.width=7, fig.height=2.3}
pattern.dur.seq <- 60:120
template <- list(true.pattern.1,
                 true.pattern.2)
  
out <- segmentPattern(
  x = x2,
  x.fs = 1,
  template = template,
  pattern.dur.seq = pattern.dur.seq,
  similarity.measure = "cor",
  x.adept.ma.W = 10,  ## smoothing parameter for similarity matrix computation
  finetune = "maxima",  ## use fine-tuning
  finetune.maxima.ma.W = 50, ## smoothing parameter for peak detection in fine-tuning
  finetune.maxima.nbh.W = 30,  ## neighborhoods length in fine-tuning
  compute.template.idx = TRUE)
out
```

Plot segmentation results. 

```{r}
## Function to plot nice results visualization 
out.plot2 <- function(val, val.sm, out){
  yrange <- c(-1, 1) * max(abs(val))
  y.h <- 0
  plt <- 
    ggplot() + 
    geom_line(data = data.frame(x = 1:length(val), y = val), 
              aes(x = x, y = y), 
              color = "grey") 
  for (i in 1:nrow(out)){
    tau1_i <- out[i, "tau_i"]
    tau2_i <- tau1_i + out[i, "T_i"] - 1
    plt <- 
      plt + 
      geom_vline(xintercept = tau1_i, color = "red") + 
      geom_vline(xintercept = tau2_i, color = "red") + 
      annotate(
        "rect",
        fill = "pink", 
        alpha = 0.3,
        xmin = tau1_i, 
        xmax = tau2_i, 
        ymin = yrange[1],
        ymax = yrange[2]
    )
  }
  plt <- 
    plt + 
    geom_line(data = data.frame(x = 1:length(val.sm), y = val.sm), 
              aes(x = x, y = y), 
              color = "black", size = 0.6, alpha = 0.8) + 
    theme_bw(base_size = 9) + 
    labs(x = "Time [s]", 
         y = "Black line: smoothed x", 
         title ="Light gray line: signal x\nBlack line: smoothed signal x\nRed vertical lines: start and end points of identified pattern occurrence\nRed shaded area: area corresponding to identified pattern occurrence")
  plot(plt)
}
```


```{r, fig.width=7, fig.height=3}
## Plot segmetation results
out.plot2(x2, windowSmooth(x = x2, x.fs = 1, W = 50), out)
```



# References

1: Karas, M., Straczkiewicz, M., Fadel, W., Harezlak, J., Crainiceanu, C., Urbanek, J.K. *Adaptive empirical pattern transformation (ADEPT) with application to walking stride segmentation*, Submitted to *Biostatistics*, 2018.

2: Karas, M.: [Walking strides segmentation with adept](file://localhost/Users/martakaras/Dropbox/_PROJECTS/R/adept/docs/articles/adept-strides-segmentation.html) vignette. 
















